{"meta":{"title":"诗之花绪","subtitle":"欣红的个人技术博客","description":"学无止境，学无止境呀","author":"xinhong","url":"https://shizhihuaxu.github.io"},"pages":[{"title":"","date":"2018-08-01T14:08:38.000Z","updated":"2018-08-02T07:35:19.574Z","comments":false,"path":"about/index.html","permalink":"https://shizhihuaxu.github.io/about/index.html","excerpt":"","text":"前端菜鸟，喜欢写代码，撸猫，宅。"},{"title":"categories","date":"2018-08-01T14:09:00.000Z","updated":"2018-08-01T14:14:02.558Z","comments":false,"path":"categories/index.html","permalink":"https://shizhihuaxu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-01T14:08:46.000Z","updated":"2018-08-01T14:11:09.852Z","comments":false,"path":"tags/index.html","permalink":"https://shizhihuaxu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"规范化你的 commit message","slug":"normalize-commit-message","date":"2019-04-28T03:02:27.275Z","updated":"2019-04-28T03:20:08.260Z","comments":true,"path":"2019/04/28/normalize-commit-message/","link":"","permalink":"https://shizhihuaxu.github.io/2019/04/28/normalize-commit-message/","excerpt":"","text":"steps在这之前，你需要安装 node 环境，因为下面的方法需要使用 npm 安装这些工具。 安装 commit message 工具 cnpm install -g commitizen 安装生成 changelog 的工具 cnpm install -D conventional-changelogcnpm install -D conventional-changelog-cli 检测changelog工具是否安装成功 npm ls -g -depth=0可以得到这两个项目的名称表示安装成功 在项目目录中初始化工具 commitizen init cz-conventional-changelog –save –save-exact 以后，凡是用到 git commit 命令，一律改为使用 git cz 。这时，就会出现选项，用来生成符合格式的 Commit message。 在 git bash 中可能存在无法切换提交类型，可以使用 cmd 代替。 commit 类型feat: 新特性 fix: 修改问题 refactor: 代码重构 docs: 文档修改 style: 代码格式修改, 注意不是 css 修改 test: 测试用例修改 chore: 其他修改, 比如构建流程, 依赖管理.","categories":[{"name":"git","slug":"git","permalink":"https://shizhihuaxu.github.io/categories/git/"}],"tags":[{"name":"git 进阶","slug":"git-进阶","permalink":"https://shizhihuaxu.github.io/tags/git-进阶/"}]},{"title":"在使用 Webpack 构建的项目中配置 scss","slug":"webpack-scss","date":"2019-04-28T01:47:13.657Z","updated":"2019-04-28T03:29:28.045Z","comments":true,"path":"2019/04/28/webpack-scss/","link":"","permalink":"https://shizhihuaxu.github.io/2019/04/28/webpack-scss/","excerpt":"","text":"Dependencies sass-loader 加载 scss 文件并编译 scss 文件 style-loader 将 css 文件通过 style 标签插入页面 css-loader 处理css文件中的@import 和 url() node-sass 将 sass 文件编译为 css 文件 sass-rescources-loader 用于在 webpack 中统一引入某些 sass 文件，less 可以使用 style-rescources-loader 1cnpm install -D css-loader style-loader sass-loader node-sass sass-rescources-loader Troubleshooting全局引入某些经常使用的 scss 文件​ 像mixin 和 variable 文件通常是在每个组件中都会用到的，每个组件使用的时候都需要手动的引入一遍，那么有没有一种方法能够只引入一次便可全局使用呢 ? 这就需要使用到 sass-rescources-loader。 ​ 如果你使用vue-cli 搭建项目，那么可以在 build/utils.js 文件中进行如下修改： 12345678910111213scss: generateLoaders('sass').concat( &#123; loader: 'sass-resources-loader', options: &#123; resources: path.resolve(__dirname, '../src/assets/your.scss') // 多个文件可写为数组 //resources: [ // path.resolve(__dirname, '../src/style/variable.scss'), // path.resolve(__dirname, '../src/style/mixin.scss') ] &#125; &#125;) 文件引入路径的问题​ 在引入文件时，会存在文件路径过深的问题，就要写很长一段路径。我们可以通过在 webpack 中配置路径别名解决，例如使用 @ 符号代替 src 文件夹所在的路径，然后再引入组件时直接使用 @/components/index.vue。 ​ 但是在 css 文件，如 less, sass, stylus 中，使用 @import “@/style/theme” 的语法引用相对 @ 的目录确会报错，”找不到 ‘@’ 目录”，说明 webpack 没有正确识别资源相对路径。 ​ 这是由于css 文件会被用 css-loader 处理，这里 css @import 后的字符串会被 css-loader 视为绝对路径解析，因为我们并没有添加 css-loader 的 alias，所以会报找不到 @ 目录。 ​ 解决办法： ​ 一、直接为 css-loader 添加 ailas 的路径，但是在 vue-webpack 给的模板中，单独针对这个插件添加配置就显得麻烦冗余了； 二、在引用路径的字符串最前面添加上 ~ 符号，如 @import “~@/style/theme”；Webpack 会将以 ~ 符号作为前缀的路径视作依赖模块而去解析，这样 @ 的 alias 配置就能生效了。","categories":[{"name":"scss","slug":"scss","permalink":"https://shizhihuaxu.github.io/categories/scss/"}],"tags":[{"name":"scss 基础","slug":"scss-基础","permalink":"https://shizhihuaxu.github.io/tags/scss-基础/"}]},{"title":"在 Windows 上使用 Docker","slug":"docker-install","date":"2019-04-02T03:07:44.681Z","updated":"2019-04-08T06:55:56.499Z","comments":true,"path":"2019/04/02/docker-install/","link":"","permalink":"https://shizhihuaxu.github.io/2019/04/02/docker-install/","excerpt":"","text":"Part 1: 检查计算机是否可以使用 Docker Desktop for Windows如果计算机符合以下所有要求，则可以使用 Docker Desktop for Windows，否则需要安装 Docker Toolbox。 win10 专业版、企业版或教育版 64位操作系统(1607 Anniversary Update, Build 14393 or later) 至少 4GB 的RAM CPU SLAT(Second Level Address Translation)-capable 特性 BIOS 中启用虚拟化 如何查看系统信息控制面板 -&gt; 系统和安全 -&gt; 系统 即可查看Windows 版本、内存和处理器版本。 如何检查CPU 是否支持 SLAT 特性这里是一篇来自于Dawa Law博客的文章How to Check for SLAT Capable CPU 翻译为如下步骤： 依然是在控制面板中的系统信息中查看处理器版本 如果是 Intel 处理器，请在这里找到自己的 CPU，如果是 AMD ，请看这里 选点击 CPU 名称进入详情页。如果是 Intel ，请查看 Intel® VT-x with Extended Page Tables (EPT) 选项，为 Yes 表示支持。如果为 AMD ,请查看 AMD Virtualization Technology 选项，为 Yes 表示支持。 如何查看是否启用虚拟化ctrl + alt + delete 打开任务管理器，在性能选项页可以看到虚拟化这项描述。 Part 2: 使用 Docker Desktop for Windows 下载。 Docker Desktop for Windows下载地址，在 Install Docker Desktop for Windows desktop app 标题下的描述部分有一个 “download.docker.com” 链接地址，点击即可直接下载。 在 BIOS 中开启虚拟化。 开始菜单 -&gt; 设置 -&gt; 更新和安全 -&gt; 恢复 -&gt; 立即重启 -&gt; 疑难解答 -&gt; 高级选项 -&gt; UFFI设置 -&gt; Intel Virtual Technology -&gt; 启用 开始 Hyper-V 服务。 右键windows图标 -&gt; 应用和功能 -&gt; 相关设置 程序和功能 -&gt; 启用或关闭windows 功能 -&gt; 勾选Hyper-V所有内容 ​ 或 或以管理员身份运行 CMD , 输入以下命令, 在任务管理器 -&gt; 性能 页面查看是否成功启用虚拟化。 1DISM /Online /Enable-Feature /All /FeatureName:Microsoft-Hyper-V 设置国内镜像源。 任务栏 Docker 图标 -&gt; 右键 -&gt; settings -&gt; Daemon -&gt; registry mirrors 输入国内镜像源 1https://registry.docker-cn.com 设置共享磁盘。 settings -&gt; shared drives 勾选要共享的磁盘 ，可能会提示输入用户名密码，输入操作用户的账号密码。 重置镜像存储位置。 settings -&gt; advanced -&gt; disk image location 选择一个文件夹。 Part 3: 使用 Docker Toolbox 下载。 Docker Toolbox 下载地址 在 BIOS 中开启虚拟化。 开启 Hyper-V 服务。 启动安装程序，如果安装过 git 那么取消勾选 git for windows。 双击 Docker Quickstart Terminal 启动服务，提示查找 bash.exe。 ​ 由于我们没有选择安装git ，这是由于快捷方式所指向的路径有问题，指向的目标是 git\\bin\\bash.exe，修改为正确的地址后即可正常打开。 ​ 右键quickstart图标 -&gt; 属性 -&gt; 目标 输入你的 git bash.exe 路径，例如：D:\\git\\bin\\bash.exe -&gt; 应用 手动安装 boot2docker.iso。 配置正确 bash 路径后双击 quick start 会出现download boot2docker.iso 但是这样下载比较慢，可以直接到 github 上下载与提示版本相对应的boot2docker.iso文件放入提示中的目标文件夹 C:\\Users\\用户名/\\.docker\\machine\\cache文件夹下 测试安装成功。 运行 docker run hello-world 出现 Unable to find image ‘hello-world:latest’ locally… 即为安装成功。 设置国内镜像源。 Docker 中文文档提供了设置国内镜像的方法。 12345或者：docker-machine ssh defaultsudo sed -i &quot;s|EXTRA_ARGS=&apos;|EXTRA_ARGS=&apos;--registry-mirror=https://registry.docker-cn.com|g&quot; /var/lib/boot2docker/profileexitdocker-machine restart default 更改docker 镜像的默认存储位置 默认情况下，docker-machine创建的虚拟机文件，是保存在C盘的C:\\Users\\用户名\\docker\\machine\\machines\\default 目录下的，如果下载和使用的镜像过多，那么必然导致该文件夹膨胀过大。具体操作如下： 1234567891.使用 docker-machine stop default 停掉Docker的虚拟机。2.打开 VirtualBox UI，选择 “全局工具” 下的 “虚拟介质管理”，我们可以看到Docker虚拟机用的虚拟硬盘的文件disk.vmdk。3.选中“disk”，然后点击菜单中的“复制”命令，注意不要直接复制粘贴，根据向导，把当前的disk复制到另一个盘上面去。复制时文件类型选择默认VDI，动态分配，目标文件夹。4.点击 “虚拟电脑工具” 回到 VirtualBox 主界面，右键 “default” 这个虚拟机，选择 “设置” 命令，在弹出的窗口中选择 “存储” 选项。5.把disk.vmdk从“控制器SATA”中右键删除，然后右上角重新添加“虚拟硬盘”我们刚才复制到另外一个磁盘上的那个文件。 设置共享磁盘 ​ 如果您的项目位于其他地方，或者需要访问主机文件系统上的其他目录，您可以使用VirtualBox UI添加它们。 ​ 设置 -&gt; 共享文件夹-&gt; 点击加号图标-&gt; 选择一个文件夹-&gt;选择自动挂载、固定分配。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://shizhihuaxu.github.io/categories/Docker/"}],"tags":[{"name":"Docker 基础","slug":"Docker-基础","permalink":"https://shizhihuaxu.github.io/tags/Docker-基础/"}]},{"title":"","slug":"line-height","date":"2018-11-27T07:02:51.176Z","updated":"2018-11-30T01:10:17.946Z","comments":true,"path":"2018/11/27/line-height/","link":"","permalink":"https://shizhihuaxu.github.io/2018/11/27/line-height/","excerpt":"","text":"line-height详解为 length 时子元素直接继承 为 number 时显式设置行高的元素以自身字体大小计算行高，子元素继承number然后根据子元素自身字体大小计算子元素行高 为 em时em 为 font-size 的单位时，相对于父元素字体大小 em 为其它属性的单位时, 相对于自身字体大小 为 % 时总结： line-height 为 number时，父元素根据自身字体大小计算行高，子元素首先继承number的值再根据自身字体大小计算行高。 line-height 为 em 和 % 时，父元素根据自身字体大小计算出行高的值，子元素继承这个被计算出来的值。 所以说显式设置行高的元素均以自身字体大小来计算行高， 区别在于行高的继承性，未显式设置 行高大小 元素的行高是多少 所以讨论的情况是，父元素显式设置行高而子元素未显式设置行高 父元素的行高时 px 时， 直接继承 父元素的行高是em 和 % 时，父元素根据自身字体大小计算出行高，子元素直接继承计算出的行高 父元素的行高是number 时，子元素只继承这个number ，然后子元素根据自身字体大小计算出自身行高","categories":[],"tags":[]},{"title":"git的常用方法与基本命令","slug":"gitGettingStart","date":"2018-09-06T07:22:56.616Z","updated":"2018-09-07T02:06:21.333Z","comments":true,"path":"2018/09/06/gitGettingStart/","link":"","permalink":"https://shizhihuaxu.github.io/2018/09/06/gitGettingStart/","excerpt":"","text":"配置设置全局用户名和邮箱账号123git config –global user.name \"username\"git config –global user.email \"email\" 生成并配置ssh-key1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 生成的 ssh-key 一般位于C盘用户文件夹下 .ssh文件夹中，若未找到，可能是此文件夹被隐藏，在文件管理器上选择查看选项，勾选隐藏的项目即可显示。 将id_rsa.pub中的内容添加至github或其它代码托管平台的ssh-key配置中。 添加至github后使用以下命令测试是否添加成功。 1234567ssh -T git@github.com// successHi ..., You&apos;ve successfully authenticated....// errorPermission denied ... 开始使用克隆一个已有的仓库到本地现在我们可以使用 ssh 的项目地址克隆代码仓库了 1git clone git@github.com:vuejs/vue.git 如果你希望在某个开源项目上贡献代码，由于没有写入的权限，需要使用fork + pull request的形式贡献代码或者向作者请求写入权限，将项目fork到自己的代码库中，然后再clone到本地。 在团队协作的项目中，我们可能需要拉取指定的分支工作，可以使用如下命令克隆指定分支的代码 1git clone -b branchName git@github.com:vuejs/vue.git // 克隆指定分支的代码 新建和切换分支新建一个git项目的时候默认的分支是master, 多数情况下我们不会在主分支下进行开发，需要新建一个分支，切换到某个分支工作，确定代码没有问题后再提交到主分支。 123git branch dev // 新建一个 dev 分支git checkout dev // 切换到 dev 分支 git checkout -b dev // 新建并切换到 dev 分支 暂存代码有时我们在自己的分支上工作，代码还不能提交，却需要解决一个问题，可以储存代码 1git stash 可以进行多次储存，每次储存都会生成一个唯一名称，恢复代码时可以指定名称恢复,如果未指明，默认使用最近的储存并尝试应用它 123git stash apply &lt;stash@&#123;0&#125;&gt;或git stash pop (应用并从存储的堆栈中移出) 提交代码查看文件状态1git status 提交到暂存区123git add test.js // 提交单个文件git add -u(--update) // 只提交被修改的文件，不包含新文件git add . / git add -A(--all) // 提交所有文件(git v2) 提交更新1git commit -m &quot;提交说明&quot; 推送到远程仓库如果是第一次提交代码，会默认在远程分支生成一个与当前分支同名的分支 12345678//建立本地分支与远程某分支的关联git branch --set-upstream-to origin/branchName locaBranchName // 将本地dev分支推送到远程的dev分支,并将本地分支与远程分支关联git push -u origin/dev（远程) dev(本地) 相当于执行了git push origin dev + git branch --set-upstream-to=origin/dev dev 关联后可使用 git push 直接推送代码 撤销提交123456789101112131415// 撤销工作区的修改git checkout -- &lt;file&gt;// 撤销 git add 后并没有commit的修改(暂存区)git reset HEAD &lt;file&gt;// 撤销已经 commit 但未 push 的提交git log //查看提交历史git reset --hard commit_idgit reset commit_id // 撤销已经 push 到远程仓库的提交1.首先在本地回退到上一个版本git reset commit_idgit push --force git reset –hard 参数表示将本地代码也回退为指定commit 的代码 git reset –soft 或 未使用参数，只是改变了 HEAD 的指向，本地代码并不会发生变化 拉取远程分支的代码1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 合并分支1git merge anotherBranch // 将另一个分支合并到当前分支 取消合并1git reset --hard HEAD 如果合并了分支后进行了其它的操作 1git revert commit_id 解决冲突git add 能用于合并时把有冲突的文件标记为已解决状态","categories":[{"name":"git","slug":"git","permalink":"https://shizhihuaxu.github.io/categories/git/"}],"tags":[{"name":"git 入门","slug":"git-入门","permalink":"https://shizhihuaxu.github.io/tags/git-入门/"}]},{"title":"js的隐式数据类型转换规则（二）实践篇","slug":"two-type-conversion","date":"2018-08-02T03:18:39.428Z","updated":"2018-08-02T06:19:54.747Z","comments":true,"path":"2018/08/02/two-type-conversion/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/two-type-conversion/","excerpt":"","text":"四则运算中的转换这些操作符会尝试将他们的操作数转换为数字（使用Number()），如果操作数没法转换为数字的话，他们的结果就是NaN。 ‘+’运算符基本类型1234567891011121314151617a. true+1 Number(true)+1 //2b. undefined+1 Number(undefined)+1 //NaNc. null+1 Number(null)+1 //1d. \"2\"+1 //21 如果使用‘+’符号时，存在一个值为字符串类型，那么另一个值无条件的被转化为字符串类型e. “dede”+1 //dede1 引用类型12345678910111213141516171819202122232425a. []+1 // \"1\"(string)b. ['12']+1 // '121'c. var f=function()&#123;&#125; ; f+1; // \"function()&#123;&#125;1\" f.valueOf() //f ()&#123;&#125; 函数本身 f.toString() // 'function()&#123;&#125;' 字符串类型 左侧为字符串类型，右侧自动转化为字符串类型，其它的同理。d. 1+&#123;&#125; 与&#123;&#125;+1 Object.prototype.valueOf.call(&#123;&#125;) //&#123;&#125; Object.prototype.toString.call(&#123;&#125;) //\"[object Object]\" 所以1+&#123;&#125;的结果是\"1[object Object]\" 对于&#123;&#125;+1，&#123;&#125;被解释成代码块，执行的操作就是+1,结果为1e. &#123;&#125;+[] //0 &#123;&#125;被当成是代码块，执行的是+[]这个取正运算，[]首先被转化为string类型的空字符串，由于取正运算符，转化为0 取正值(均转化为number类型) ‘+’作为一元操作符时，都是尝试将他们的操作数转换为数字（使用Number()），如果操作数没法转换为数字的话，他们的结果就是NaN。（转化的具体值见第一篇的表格） 减号，乘号，除号运算这些操作符会尝试将他们的操作数转换为数字（使用Number()），如果操作数没法转换为数字的话，他们的结果就是NaN。 比较运算符中的判断1234567891011121. []==![] //true a. [].valueOf() //[] 返回自身，不是一个基本类型 b. [].toString() //\"\"返回一个字符串，是一个基本类型 c. ![]首先会进行显式类型转换，将其转化为 false d. 如果 x,y 类型不一致，且 x,y 为 String、Number、Boolean 中的某一类型，则将 x,y 使用 toNumber 函数,转化为 Number 类型再进行比较。 e.Number(\"\")===Number(false) //true2. +0==-0 //true3. undefined==null //true4. NaN==NaN //false alert等方法中参数是某一固定类型的时候的转换alert(string)传入的参数会发生隐式类型转换，转换为string","categories":[{"name":"Data type conversion","slug":"Data-type-conversion","permalink":"https://shizhihuaxu.github.io/categories/Data-type-conversion/"}],"tags":[{"name":"隐式数据类型转换实践","slug":"隐式数据类型转换实践","permalink":"https://shizhihuaxu.github.io/tags/隐式数据类型转换实践/"}]},{"title":"置换元素","slug":"ReplacementElements","date":"2018-08-02T03:18:39.425Z","updated":"2018-08-02T04:52:23.313Z","comments":true,"path":"2018/08/02/ReplacementElements/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/ReplacementElements/","excerpt":"","text":"什么是置换元素？&emsp;&emsp;今天在看教程的时候，跟着做了一下canvas的使用，未来让页面看起来舒服点我想把canvas居中，于是我想到了margin:0 suto;那么问题来了，没有办法居中，但是设置了display:block以后就可以了，我一直以为canvas是块级元素，查了一下margin这样写不能居中的原因有哪些，一个是没声明文档类型，二是没设置宽度，三是可能使用了浮动属性，这些都没有问题，那是什么原因呢？于是我决定查一下canvas到底是什么元素，在segmentfault中发现了同样的一个问题，原来canvas是内联元素，并且是内联可置换元素。对于内联可置换元素来说，当margin-left和margin-right被设置为auto的时候，他的值为0。 &emsp;&emsp;一个内容不受CSS视觉格式化模型控制，CSS渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。 置换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。 行内级置换元素的宽高宽度： 若宽高的计算值都为 auto 且元素有固有宽度，则 width 的使用值为该固有宽度；典型的例子是：拥有默认宽高的 input 当宽度的计算值为auto时，则宽度使用值为其默认的固有宽度 若宽度的计算值为 auto 且元素有固有宽度，则 width 的使用值为该固有宽度；例子同上 若宽度的计算值为 auto 且高度有 非auto 的计算值，并且元素有固有宽高比，则 width 的使用值为 高度使用值 * 固有宽高比；典型的例子：img 当只定义了其高度值时，其宽度将会根据固有宽高比进行等比设置 除此之外，当 width 的计算值为 auto 时，则宽度的使用值为 300px典型的例子：比如iframe, canvas 高度： 若宽高的计算值都为 auto 且元素有固有高度，则 height 的使用值为该固有高度； 若高度的计算值为 auto 且元素有固有高度，则 height 的使用值为该固有高度； 若高度的计算值为 auto 且宽度有 非auto 的计算值，并且元素有固有宽高比，则 height 的使用值为：宽度使用值 / 固有宽高比； 若高度的计算值为 auto 且上述条件完全不符，则 height 的使用值 不能大于150px，且宽度不能大于长方形高度的2倍。 其它类型置换元素的宽高的定义都参照行内置换元素的定义 其它说明 置换元素有:img,input,select,textarea,object,canvas,iframe等 同样容易被混淆的内联元素有： img 内联置换元素 inline-block: selecttextareainputbutton 块级元素 ul 块元素和块级元素的区别是 块元素只是display:block的元素块级元素也可以是display:table | list-item | flex | grid","categories":[{"name":"HTML","slug":"HTML","permalink":"https://shizhihuaxu.github.io/categories/HTML/"}],"tags":[{"name":"置换元素","slug":"置换元素","permalink":"https://shizhihuaxu.github.io/tags/置换元素/"}]},{"title":"js的隐式数据类型转换规则（一）原理篇","slug":"one-type-conversion","date":"2018-08-02T03:18:39.422Z","updated":"2018-08-02T06:19:30.579Z","comments":true,"path":"2018/08/02/one-type-conversion/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/one-type-conversion/","excerpt":"","text":"隐式类型转换隐式数据类型转换通常发生在比较大小，是否相等，加减乘除等运算、或当前运行环境的默认输出类型为固定值时。 例如：使用非严格相等操作符(==)判断两个值是否相等时，如果两个值的类型不同（typeof），会将两个值隐式的转化为相同的类型后再执行严格相等的比较。（其中一个或者两个值都发生类型转换） 1.原始类型之间的转换使用Number(),String(),Boolean()。 原始值 转化为数值类型 转化为字符串类型 转化为布尔类型 false 0 “false” true 1 “true” +0或-0 ‘’+0”或”-0” false 1 “1” true NAN “NAN” false infinity “infinity” true -infinity “-infinity” true undefined NAN “undefined” false null 0 “null” false “” 0 false “10” 10 true “abcd” NAN true 2.当引用类型转换为基本类型时则使用ToPrimitive函数。 123456789101112131415161718192021222324252627ToPrimitive(input, PreferredType?)的简单实现，代码来源于：https://zhuanlan.zhihu.com/p/29064256 var ToPrimitive = function(obj,preferredType)&#123; var APIs = &#123; typeOf: function(obj)&#123; return Object.prototype.toString.call(obj).slice(8,-1); &#125;, isPrimitive: function(obj)&#123; var _this = this, types = ['Null','Undefined','String','Boolean','Number']; return types.indexOf(_this.typeOf(obj)) !== -1; &#125; &#125;; // 如果 obj 本身已经是原始对象，则直接返回 if(APIs.isPrimitive(obj)) &#123;return obj;&#125; // 对于 Date 类型，会优先使用其 toString 方法；否则优先使用 valueOf 方法 preferredType = (preferredType === 'String' || APIs.typeOf(obj) === 'Date' ) ? 'String' : 'Number'; if(preferredType==='Number')&#123; if(APIs.isPrimitive(obj.valueOf())) &#123; return obj.valueOf()&#125;; if(APIs.isPrimitive(obj.toString())) &#123; return obj.toString()&#125;; &#125;else&#123; if(APIs.isPrimitive(obj.toString())) &#123; return obj.toString()&#125;; if(APIs.isPrimitive(obj.valueOf())) &#123; return obj.valueOf()&#125;; &#125; throw new TypeError('TypeError');&#125; 原始值 转化为数值类型 转化为字符串类型 转化为布尔类型 [] 0 “” true [10] 10 “10” true [1,2] NaN “1,2” true [“10”] 10 “10” true [“abcd”] NaN “abcd” true function(){} NaN “function(){}” true {} NaN “[object Object]” true 以下几种类型在转化为布尔值时为false，其它的均为truenull，undefined，0，””，NaN（共五种） 注意:如果使用new操作符创建的对象隐式转换为boolean类型都是true，哪怕是new String(”); 运行环境和操作符对隐式类型转换的影响数据到底是被转化为number还是string受到运行环境和操作符的影响。 运行环境的影响​ 很多内置函数期望传入的参数的数据类型是固定的，如:alert(value)方法，它期望传入的value值是一个string类型，但是如果我们传入的是number类型或者object类型等非string类型的数据的时候，就会发生数据类型的隐式转换。这就是环境运行环境对数据类型转换的影响 操作符的影响 当+号作为一元操作符操作单操作数的时候，他就会将这个数转换为Number类型 当+号作为二元操作符时，如果两个操作数中存在一个String类型的话，那么另外一个操作数也会无条件地转换为字符串. 在第1步转换后，如果有运算元出现原始数据类型是”字符串”类型值时，则另一运算元作强制转换为字符串，然后作字符串的连接运算(concatenation)。 当+号作为二元操作符时，如果两个操作数一个都不是字符串的话，两个操作数会隐式转换成数字类型(如果无法成功转换成数字，则变成NaN，再往下操作)，再进行加法算数操作. 当算数运算的操作符是+号以外的其他操作数时，两个操作数都会转成数字类型进行数字运算。 == 与！=操作符的运算规则1234567891011121314151617x==y的判断1.如果x与y的类型（typeof）相同，存在以下几个特殊情况需要注意 a.如果x与y均为undefined,或null,返回true b.如果x与y均为number类型，且至少有一个值为NAN,返回false c.+0==-0,返回true d.undefined==null,返回true e.x,y均为某个对象的实例，返回true2.如果 x,y 类型不一致，且 x,y 为 String、Number、Boolean 中的某一类型，则将 x,y 使用 toNumber 函数转化为 Number 类型再进行比较。3.如果 x，y 中有一个为 Object，则首先使用 ToPrimitive 函数将其转化为原始类型，再进行比较。 复杂对象转换原理复杂对象是以什么标准来判断ToPrimitive(input,preferredType)操作传入的preferredType值到底是number还是string呢？（可以见上面代码部分，这里做个简单说明） 如果运行环境非常明确的需要将一个复杂对象转换为数字则传入number如 Number(value) 和 +value 则传入number 如果运行环境非常明确的需要将一个复杂对象转换为字符串则传入string如String(value) 和 alert(value) 则传入string 如果是用+号连接两个操作数，操作数在确定确定其中只要有一个为字符串的时候另外一个操作数会转为字符串，ToPrimitive()会传入string，但是如果两个操作数都不能确定是字符串的时候则默认传入number进行数据类型转换(Date对象是一个例外，它会默认传入string)。 ToPrimitive的转换示例12345[\"12\"]+1; //‘121’[\"12\"].valueOf() // [\"12\"][\"12\"].toString() //\"12\" 首先对于这个引用类型preferredType参数默认会是number，这个时候调用传入对象的valueOf()方法，如果他的返回值类型是一个基本类型，那么就返回这个值，如果不是，则调用toString()方法，返回这个基本类型的值。","categories":[{"name":"Data type conversion","slug":"Data-type-conversion","permalink":"https://shizhihuaxu.github.io/categories/Data-type-conversion/"}],"tags":[{"name":"隐式数据类型转换原理","slug":"隐式数据类型转换原理","permalink":"https://shizhihuaxu.github.io/tags/隐式数据类型转换原理/"}]},{"title":"toString()的一道题目","slug":"operator","date":"2018-08-02T03:18:39.418Z","updated":"2018-08-02T05:17:42.964Z","comments":true,"path":"2018/08/02/operator/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/operator/","excerpt":"","text":"123453.toString()3..toString()3...toString()//error , 3 ,error 解析： ​ 第一个：点运算符会被优先识别为数字常量的一部分，然后才是对象属性访问符。所以 3.toString() 实际上被JS引擎解析成 (3.)toString()，显然会出现语法错误。 ​ 第二个：相当于(3.).toString()，3. 为浮点数，应该是被编译为了对象，所以其实相当于 3.0.toString() == “3” ​ 第三个：原理同一 来源于stackoverflow的同样一个问题 ​","categories":[{"name":"Object","slug":"Object","permalink":"https://shizhihuaxu.github.io/categories/Object/"}],"tags":[{"name":"Object","slug":"Object","permalink":"https://shizhihuaxu.github.io/tags/Object/"}]},{"title":"HTML5+PHP文件上传学习笔记","slug":"fileUpload","date":"2018-08-02T03:18:39.416Z","updated":"2018-08-02T06:19:13.617Z","comments":true,"path":"2018/08/02/fileUpload/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/fileUpload/","excerpt":"","text":"几个上传插件的分析对比下面是我整理的几个插件的分析对比数据，只选择几项展开说明，仅供参考。 项目 Uploadify Plupload2.3.1 DropZone.js Fine Uploader5.15.0 兼容性 IE 8+ IE 6+ IE 10+ IE 8+ 多文件 支持 支持 支持 IE10+ 图片预览 不支持 不支持 支持 支持（IE 10+） 拖拽上传 html5版本支持 仅html5版支持chrome21+支持文件夹 支持 支持（甚至chrome和opera15+中的文件夹） 大文件 分块上传 分块上传 自动上传 支持 不支持 不支持 支持 进度条 有 无 无 可自定义（IE10+） 功能亮点 1、flash和html5两个版本2、可更改上传的文件名3、由接口参数和CSS控制外观4、高度可定制 1、自动侦测环境，多种上传方式，兼容性好。2、支持自动重试3、依赖自由4、图片上传前压缩5、多文件队列上传 1、全面的事件处理选项2、依赖自由3、可删除已上传的文件 1、自动重传2、暂停\\恢复上传(IE10+)3、删除已上传文件4、粘贴上传（chrome,opera15+）5、无服务器上传6、提供服务器脚本或自定义7、使用接口控制外观 下载地址 http://www.uploadify.com/ http://www.plupload.com/ http://www.dropzonejs.com/ https://fineuploader.com/ (Uploadify有flash和html5两个版本，flash对IE兼容性较好，IE的7、8、9 不支持html5的File API 和xhr2使用FormData) 相关 API 详解XMLHttpRequest Level2 设置请求的超时时间 1234567var xhr=new XMLHttpRequest();//IE new ActiveXObject('Microsoft.XMLHTTP');xhr.timeout=1000;//(ms)xhr.ontimeout=function(e)&#123;&#125; 接收二进制数据 123xhr.responseText='blob'//或ArrayBuffer数组 二进制;var blob = new Blob([xhr.response], &#123;type: ''&#125;); 进度 ​ 监听progress事件，需要注意的是，上传的progress属于XMLHttpRequest.upload对象，下载的progress属于XMLHttpRequest对象 12345678xhr.upload.onprogress=function(e)&#123; if(e.lengthComputable)&#123; //lengthComputable是一个表示进度信息是否可用的布尔值 //loaded表示已经接收的字节数，total表示根据Content-Length响应头部确定的预期字节数。 var percent=e.loaded/e.total; console.log(percent); &#125; &#125; 终止 方法：abort() 事件：onabort 其它事件(IE9+) loadstart 当接收到数据的第一个字节时触发 error 发生错误时触发 load 接收到完整数据时触发 loadend 在通信完成或者触发error、abort或load事件后触发 FileList1&lt;input type=&quot;file&quot; multiple=&quot;multiple&quot;/&gt; //IE10+ 支持multiple属性 当没有multiple属性时，FileList的长度为1，需要注意的是FileList对象不能在js中直接访问 File继承Blob对象的所有属性和方法 所有属性均为只读属性 lastModified 最后的修改时间 时间戳 IE10+ lastModifiedData 不再提倡使用，但是还可以使用 name 文件名 IE11+ size 文件大小 IE11+ type 文件类型 slice(start，end); FileReader readyState EMPTY 0 尚未加载数据。 LOADING 1 数据正在加载。 DONE 2 整个读取请求已经完成。 error 读取文件时发生的错误 result 文件的内容 事件处理程序 (1) loadstart 开始读取时 (2) progress 读取时 (3) abort 中止时 (4) error 发生错误时 (5) load 读取操作成功时 (6) loadend 读取完成（成功或失败）时 方法 (1) readAsDataURL() (2) readAsText() (3) readAsArrayBuffer() (4) abort() 中止读操作 实现部分功能的思路 xhr2新增了formData接口，可以通过js用一些键值对来模拟一系列表单控件。使用FormData的最大优点就是可以异步上传二进制文件，二进制文件一般除文本文件外的图形文件、可执行文件等。设置enctype=”multipart/form-data”,可上传二进制数据，用于表单里有图片上传。默认情况，这个编码格式是application/x-www-form-urlencoded，不能用于文件上传。 非IE6版本的IE由于安全问题直接设置img的src无法显示本地图片，可以将图片转换为base64编码。 多文件上传多文件上传源码，后台使用$_FIlES对上传结果遍历，并将这些临时文件移动到保存上传图片的文件夹的操作，在此不做详细说明。 文件分块上传 defmain 前辈的文章PHP搭建大文件切割分块上传功能 提供了一个一个很好的思路。 前端主要是利用html5的File API 的slice方法对文件进行分割，使用 xhr2的FormData对象构造上传数据。 拖放上传这里使用到了HTMl5 拖放的API DataTransfer对象 (1) DataTransfer.files包含数据传输上可用的所有本地文件的列表。如果拖动操作不涉及拖动文件，则此属性是空列表。 (2) DataTransfer.types 只读 strings提供在dragstart事件中设置的格式的数组。 1234567&lt;input id=\"mylist\" type=\"file\"/&gt;var dropZone=document.getElementById(\"mylist\");dropZone.ondrop=function(e)&#123; console.log(e.dataTransfer.files[0]);&#125; 图片预览​ 使用html5的FileReader读取本地文件，包括readAsText(),readAsDataURL(),readAsArrayBuffer()三个方法。 123456789101112131415161718//创建一个FileReader对象&lt;input id=\"myfile\" type=\"file\"/&gt; &lt;img src=\"\" id=\"img\"/&gt; var myfile=document.getElementById(\"myfile\"), img=document.getElementById(\"img\"), reader=new FileReader(); myfile.ondrop=function(e)&#123; var url=\"\"; reader.readAsDataURL(e.dataTransfer.files[0]); reader.onload = function(evt) &#123; url = evt.target.result; img.setAttribute(\"src\",url); &#125; &#125; 进度条通过监听 xhr.upload.onprogress实现上传进度条效果。12345678910var xhr=new window.XMLHttpRequest();xhr.upload.onprogress=function(e)&#123; if(e.lengthComputable)&#123; //lengthComputable是一个表示进度信息是否可用的布尔值 //loaded表示已经接收的字节数，total表示根据Content-Length响应头部确定的预期字节数。 var percent=e.loaded/e.total; console.log(percent); &#125; &#125; 压缩上传 读取数据 创建一个image对象，监听他的onload事件 根据压缩比例算出宽高 使用canvas将图片画出来按照此宽高画出来 使用toDataURL读取成base64数据的形式上传（怎样上传） 上传 base64数据的形式是这种形式的:data:image/png;base64,someString…. 1234567891011121314151617function dataURItoBlob(dataURI) &#123; var byteString = atob(dataURI.split(',')[1]); var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; var ab = new ArrayBuffer(byteString.length); var ia = new Uint8Array(ab); for (var i = 0; i &lt; byteString.length; i++) &#123; ia[i] = byteString.charCodeAt(i);//老版本的做法 还原成二进制的字符 &#125; return new Blob([ab], &#123;type: mimeString&#125;);&#125;var fd = new FormData();var blob = dataURItoBlob(dataURL);fd.append('file', blob);上传时data:fd","categories":[{"name":"文件上传","slug":"文件上传","permalink":"https://shizhihuaxu.github.io/categories/文件上传/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://shizhihuaxu.github.io/tags/文件上传/"}]},{"title":"js 写一个倒计时函数","slug":"countDown","date":"2018-08-02T03:18:39.406Z","updated":"2018-08-02T06:18:02.522Z","comments":true,"path":"2018/08/02/countDown/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/countDown/","excerpt":"","text":"Date对象Date.parse(dateString)返回从1970年1月1日到dateString指定的日期的毫秒数 dateString有如下几点限制（这部分内容是从river.cao的博客看到的) 短日期可使用 / 日期分隔符，但是必须符合 月/日/年 的格式，例如 7/20/96 或 6/15/2008 。 以 July 10 1995 形式表示的长日期中的年、月、日可以按任何顺序排列，而且年份可以用2位数或4位数的形式表示。如果使用2位数的形式来表示年份，则该年份必须大于或等于 70。 逗号 和空格被视为分隔符。允许使用多个分隔符。 月和日的名称必须具有两个或两个以上的字符。如果两个字符所组成的名称不唯一，则该名称将解析为最晚的一个匹配日期。例如， Ju 解析为七月( July )，而不是六月( June )。Chrome不支持”Ju”这种写法。 如果提供一个日期，该日期中所说明的星期数与根据此日期中其他部分所确定的星期数不相符，则此日期中的星期数将被忽略。例如，尽管 1996 年 11 月 9 日实际上是星期五，但 Tuesday November 9 1996 还是可以被接受并进行分析。但是结果的 Date 对象中包含的是 Friday November 9 1996 。 用冒号分隔小时、分钟和秒，但所有这些内容并非都需要指定。 10: 、 10:11 和 10:11:12 都是有效的。 dateObj.getTime()&emsp;&emsp;dateObject 指定的日期和时间距 1970 年 1 月 1 日午夜（GMT 时间）之间的毫秒数。 代码这里我只写了一个思路，还有不严谨之处，仅供参考 &emsp;&emsp;这里我只写了一个思路，还有不严谨之处，仅供参考 12345678910111213141516171819202122232425262728var countDown=function(date)&#123; var pre=Date.parse(date); var loop=setInterval(function()&#123; var d=new Date(), now=d.getTime(), diff=pre-now; var hour=0, minutes=0, seconds=0; diff=Math.round(diff/1000); seconds=Math.round(diff%60); minutes=Math.round(diff/60%60); hour=Math.round(diff/3600); if(hour==0&amp;&amp;minutes==0&amp;&amp;seconds==0)&#123; clearInterval(loop); console.log('时间到啦'); &#125; console.log('还剩 hour '+hour+' minutes '+minutes+' seconds '+seconds); &#125;,1000) &#125; //使用方法 //countDown('10/06/2017 22:19:00'); 要写到具体的日期的某个时间点","categories":[{"name":"Date对象","slug":"Date对象","permalink":"https://shizhihuaxu.github.io/categories/Date对象/"}],"tags":[{"name":"Data对象","slug":"Data对象","permalink":"https://shizhihuaxu.github.io/tags/Data对象/"}]},{"title":"在ThinkPHP5.0.11中使用 CKEditor、CKFinder","slug":"ckeditor","date":"2018-08-02T03:18:39.404Z","updated":"2018-08-02T06:17:53.705Z","comments":true,"path":"2018/08/02/ckeditor/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/ckeditor/","excerpt":"","text":"插件下载地址CKEditor CKFinder 配置步骤及常见问题说明配置步骤 ​ 在页面中引入js,这里如果你使用了jquery 需要引入adapters/jquery.js 123&lt;script src=&quot;/ckeditor/ckeditor.js&quot;&gt;&lt;/script&gt; //插件的位置 根据你的保存的路径设置&lt;script src=&quot;/ckeditor/adapters/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/ckfinder/ckfinder.js&quot;&gt;&lt;/script&gt; 在页面中初始化CKEditor 12345var myeditor=CKEDITOR.replace('content',&#123; filebrowserBrowseUrl: \"/ckfinder/ckfinder.html\", filebrowserImageBrowseUrl: '/ckfinder/ckfinder.html?Type=Images', filebrowserImageUploadUrl: '/plugins/ckfinder/core/connector/php/connector.php？command=QuickUpload&amp;type=Images' &#125;); 在未做如上配置之前,CKEditor 点击上传图片的图标是没有上传按钮的,网上有一些教程说是插件默认将这个按钮style设置为隐藏了,提供的解决办法是找到相应的位置修改css,其实只要配置了上传图片的处理文件路径,“ 上传 ”按钮就会显示出来。 整合CKEditor 和 CKFinder CKEditor 只是一个富文本编辑器，没有文件浏览和文件上传的功能, CKFinder是用来上传文件和浏览服务器上的文件的，和CKEditor配合实现文件上传。 1CKFinder.setupCKEditor(myeditor,&quot;/ckfinder/&quot;); //ckfinder插件存放的相对路径 ​ 图片上传 首先在 ckfinder/config.php 中找到 $baseUrl = ‘/userfiles/‘ ,将其设置为你要保存上传文件的路径,你也可以动态设置地址。 再向下可以找到 $config[‘ResourceType’]为Images 的配置项，这里对上传图片的大小、扩展名进行配置。 常见问题首先记得更改任何配置，如果没有效果要手动清除一下浏览器缓存,使用ctrl+F5也不能全部刷新,导致我花了一下午时间找问题，才发现其实已经配置好了。 隐藏 “浏览服务器文件按钮” 1在 ckeditor/plugins/image/dialogs/image.js 找到仅有的一项 display:inline-block 将其设置为display:none;就可以隐藏掉了 缺少图像源文件地址 这是由于预览没有权限读取上传的文件的地址,更改浏览服务器文件的权限，只有用户登录后或当前用户只能查看自己上传到服务器的文件 ,在登录成功后设置一个授权字段到session中 ,不建议直接改为true,安全性较低。 1234567session_start();if(isset($_SESSION['IsAuthorized'])&amp;&amp;$_SESSION['IsAuthorized']==true)&#123; return true;&#125;else&#123; return false;&#125; 上传文件重名问题 ckfinder会按照原有的名字命名，中文的情况下可能会乱码，所以建议使用日期重命名。 1234567打开/ckfinder/core/connector/php/php5/CommandHandler/FileUpload.php 找到 sUnsafeFileName=CKFinder_Connector_Utils_FileSystem::convertToFilesystemEncoding(CKFinder_Connector_Utils_Misc::mbBasename(uploadedFile[&apos;name&apos;])); 后面加上 sExtension = CKFinder_Connector_Utils_FileSystem::getExtension(sUnsafeFileName);sUnsafeFileName=date(&apos;YmdHis&apos;).&apos;.&apos;.sExtension; 上传和图像对调位置 修改ckeditor/plugins/image/dialogs/image.js 文件。其实按钮的位置是按照以下方式排列的 ，所以只要将 uplaod部分的内容放在contents数组的第一个就好了。 123456contents:[&#123; id:&quot;info&quot; ...., id:&quot;Upload&quot; ...., id:&quot;Link&quot; ...., id:&quot;advanced&quot; ....,&#125;] ​ 清空预览区文字 123在ckeditor/config.js添加配置项 config.image_previewText=&apos; &apos;; //预览区域显示内容 去除掉不需要的选项卡 1config.removeDialogTabs = &quot;image:advanced;image:Link;&quot;; //去掉上传图片时超链接和高级按钮 获取内容，并判断是否为空 方法一：原生的方法 12editor 为初始化时创建的实例editor.document.getBody().getText() 方法二：直接getData获取数据时如果使用了空格、回车，会添加p标签，将空格转义，导致获取的长度永远不会为空。 1234567var content = editor.getData();content = content.replace(/(&amp;nbsp;)+/g,\"\");content = content.replace(/(&lt;p&gt;&lt;\\/p&gt;)+/g,\"\");content = $.trim(content);if(content==\"\")&#123;...&#125; 自定义菜单栏 参见文档可配置的项 123456// 工具栏（基础&apos;Basic&apos;、全能&apos;Full&apos;、自定义）plugins/toolbar/plugin.jsconfig.toolbar = &apos;Basic&apos;;config.toolbar = &apos;Full&apos;;编辑ckeditor目录下的的config.js文件，默认的是下面的工具栏代码，注意工具按钮是分组的，一个name内的大括号就是一个工具按钮分组，items后边是具体的按钮，“/”表示工具栏换行，“-”表示工具图标之间的中隔线“|” ​","categories":[{"name":"编辑器插件","slug":"编辑器插件","permalink":"https://shizhihuaxu.github.io/categories/编辑器插件/"}],"tags":[{"name":"CKEditor 4.5.10","slug":"CKEditor-4-5-10","permalink":"https://shizhihuaxu.github.io/tags/CKEditor-4-5-10/"},{"name":"CKFinder 2.0.2","slug":"CKFinder-2-0-2","permalink":"https://shizhihuaxu.github.io/tags/CKFinder-2-0-2/"}]},{"title":"数组去重的几种方式","slug":"array-unique","date":"2018-08-02T03:18:39.399Z","updated":"2018-08-02T07:36:23.079Z","comments":true,"path":"2018/08/02/array-unique/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/array-unique/","excerpt":"","text":"数组去重的几种方式借助ES6中Set数据结构成员的唯一性(注：以下内容来源于阮一峰老师的ES6入门在线文档) ​ ES6中Set数据结构是一个类数组结构，Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 ​ 向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。两个对象总是不等的。 ​ 再使用扩展运算符将Set转化为数组。 去重：[…new Set(array)] 借助Array.prototype.reduce()方法，先排序再去重12345678910let arr = [1,3,5,3,2,4,5];let result = arr.sort().reduce((init, current)=&gt;&#123; if(init.length === 0 || init[init.length-1]!==current)&#123; init.push(current); &#125; return init;&#125;, []);console.log(result); //[1, 2, 3, 4, 5] ​ 使用arr.sort()排序会存在一些问题，sort()默认的排序方法是根据字符串Unicode码点，在比较之前，元素会被转化成字符串，MDN上一个排序的例子： 123456var scores = [1, 10, 21, 2]; scores.sort(); //[1, 10, 2, 21]注意10在2之前,因为在 Unicode 指针顺序中\"10\"在\"2\"之前同样 Unicode 顺序上 \"80\" 要比 \"9\" 要靠前 所以尽量依照目前排序元素的特点，选择合适的compareFunction参数或选取其它方法。 遍历原有数组，利用 indexOf() 将非重复的值添加到新数组中去12345678910let arr = [1,3,5,3,2,4,5];let len = arr.length, newArr = []; for(let i=0;i&lt;len;i++)&#123; if(newArr.indexOf(arr[i])===-1)&#123; newArr.push(arr[i]); &#125;&#125;console.log(newArr); //[1, 3, 5, 2, 4] 建立一个哈希表1234567891011121314151617let arr = [1,3,5,3,2,4,5];function unique(a) &#123; let hash = &#123;&#125;, len = a.length, result = []; for (var i = 0; i &lt; len; i++)&#123; if (!hash[a[i]])&#123; hash[a[i]] = true; result.push(a[i]); &#125; &#125; return result;&#125;unique(arr); // 输出[1, 3, 5, 2, 4] ​","categories":[{"name":"js数组","slug":"js数组","permalink":"https://shizhihuaxu.github.io/categories/js数组/"}],"tags":[{"name":"数组去重","slug":"数组去重","permalink":"https://shizhihuaxu.github.io/tags/数组去重/"}]},{"title":"一段代码统计字符串中重复单词的思考","slug":"Array-reduce","date":"2018-08-02T03:18:39.398Z","updated":"2018-08-02T06:16:39.259Z","comments":true,"path":"2018/08/02/Array-reduce/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/Array-reduce/","excerpt":"","text":"统计重复字符&emsp;&emsp;看到一段代码，使用了reduce方法统计字符串中重复单词，现在我简化直接对数组进行操作，说说这么做的原理是什么。 123456var arr=[\"a\",\"b\",\"c\",\"b\",\"a\"]; arr.reduce(function(prev,next)&#123; prev[next]=(prev[next]+1)||1; return prev; &#125;,&#123;&#125;); arr.reduce(callback[, initialValue]) 回调函数第一次执行时， 123456789callback(previousValue, currentValue,currentIndex,array) - previousValue（上一次调用回调函数时的返回值，或者初始值） - currentValue（当前正在处理的数组元素） - currentIndex（当前正在处理的数组元素下标） - array（调用reduce()方法的数组） &emsp;&emsp;回调函数第一次执行时， 如果reduce有initialValue参数，那么 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值； 如果reduce没有 initialValue 参数，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。 再来看上面的那段代码，我试着输出了prev ,它是一个数组，在每一次循环中的结果时这样的 12345&#123;a: 1&#125;&#123;a: 1, b: 1&#125;&#123;a: 1, b: 1, c: 1&#125;&#123;a: 1, b: 2, c: 1&#125;&#123;a: 2, b: 2, c: 1&#125; next 则为每次循环的 currentValue 所以运行的过程应该是这样的： reduce参数获得了一个回调函数和一个空的对象作为初始值，在第一次回调时， prev={} &emsp; &emsp;next=”a” &emsp; &emsp; prev[“a”]=undefined||1然后返回prev这个数组，作为下一次的prev。 next=”b” prev[“b”]=1 &emsp; &emsp;……如此循环 对字符串的操作1234567var str=\"abcscd\", arr=str.split('');arr.reduce(function(prev,next)&#123; prev[next]=(prev[next]+1)||1; return prev;&#125;,&#123;&#125;);","categories":[{"name":"js数组","slug":"js数组","permalink":"https://shizhihuaxu.github.io/categories/js数组/"}],"tags":[{"name":"Array.prototype.reduce()","slug":"Array-prototype-reduce","permalink":"https://shizhihuaxu.github.io/tags/Array-prototype-reduce/"}]}]}