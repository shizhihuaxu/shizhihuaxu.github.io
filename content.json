{"meta":{"title":"诗之花绪","subtitle":"欣红的个人技术博客","description":"学无止境，学无止境呀","author":"xinhong","url":"https://shizhihuaxu.github.io"},"pages":[{"title":"categories","date":"2018-08-01T14:09:00.000Z","updated":"2018-08-01T14:14:02.558Z","comments":false,"path":"categories/index.html","permalink":"https://shizhihuaxu.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-08-01T14:08:38.000Z","updated":"2018-08-02T06:05:41.118Z","comments":false,"path":"about/index.html","permalink":"https://shizhihuaxu.github.io/about/index.html","excerpt":"","text":"前端菜鸟，喜欢写代码，撸猫，宅。"},{"title":"tags","date":"2018-08-01T14:08:46.000Z","updated":"2018-08-01T14:11:09.852Z","comments":false,"path":"tags/index.html","permalink":"https://shizhihuaxu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js的隐式数据类型转换规则（二）实践篇","slug":"two-type-conversion","date":"2018-08-02T03:18:39.428Z","updated":"2018-08-02T06:19:54.747Z","comments":true,"path":"2018/08/02/two-type-conversion/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/two-type-conversion/","excerpt":"","text":"四则运算中的转换这些操作符会尝试将他们的操作数转换为数字（使用Number()），如果操作数没法转换为数字的话，他们的结果就是NaN。 ‘+’运算符基本类型1234567891011121314151617a. true+1 Number(true)+1 //2b. undefined+1 Number(undefined)+1 //NaNc. null+1 Number(null)+1 //1d. \"2\"+1 //21 如果使用‘+’符号时，存在一个值为字符串类型，那么另一个值无条件的被转化为字符串类型e. “dede”+1 //dede1 引用类型12345678910111213141516171819202122232425a. []+1 // \"1\"(string)b. ['12']+1 // '121'c. var f=function()&#123;&#125; ; f+1; // \"function()&#123;&#125;1\" f.valueOf() //f ()&#123;&#125; 函数本身 f.toString() // 'function()&#123;&#125;' 字符串类型 左侧为字符串类型，右侧自动转化为字符串类型，其它的同理。d. 1+&#123;&#125; 与&#123;&#125;+1 Object.prototype.valueOf.call(&#123;&#125;) //&#123;&#125; Object.prototype.toString.call(&#123;&#125;) //\"[object Object]\" 所以1+&#123;&#125;的结果是\"1[object Object]\" 对于&#123;&#125;+1，&#123;&#125;被解释成代码块，执行的操作就是+1,结果为1e. &#123;&#125;+[] //0 &#123;&#125;被当成是代码块，执行的是+[]这个取正运算，[]首先被转化为string类型的空字符串，由于取正运算符，转化为0 取正值(均转化为number类型) ‘+’作为一元操作符时，都是尝试将他们的操作数转换为数字（使用Number()），如果操作数没法转换为数字的话，他们的结果就是NaN。（转化的具体值见第一篇的表格） 减号，乘号，除号运算这些操作符会尝试将他们的操作数转换为数字（使用Number()），如果操作数没法转换为数字的话，他们的结果就是NaN。 比较运算符中的判断1234567891011121. []==![] //true a. [].valueOf() //[] 返回自身，不是一个基本类型 b. [].toString() //\"\"返回一个字符串，是一个基本类型 c. ![]首先会进行显式类型转换，将其转化为 false d. 如果 x,y 类型不一致，且 x,y 为 String、Number、Boolean 中的某一类型，则将 x,y 使用 toNumber 函数,转化为 Number 类型再进行比较。 e.Number(\"\")===Number(false) //true2. +0==-0 //true3. undefined==null //true4. NaN==NaN //false alert等方法中参数是某一固定类型的时候的转换alert(string)传入的参数会发生隐式类型转换，转换为string","categories":[{"name":"Data type conversion","slug":"Data-type-conversion","permalink":"https://shizhihuaxu.github.io/categories/Data-type-conversion/"}],"tags":[{"name":"隐式数据类型转换实践","slug":"隐式数据类型转换实践","permalink":"https://shizhihuaxu.github.io/tags/隐式数据类型转换实践/"}]},{"title":"置换元素","slug":"ReplacementElements","date":"2018-08-02T03:18:39.425Z","updated":"2018-08-02T04:52:23.313Z","comments":true,"path":"2018/08/02/ReplacementElements/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/ReplacementElements/","excerpt":"","text":"什么是置换元素？&emsp;&emsp;今天在看教程的时候，跟着做了一下canvas的使用，未来让页面看起来舒服点我想把canvas居中，于是我想到了margin:0 suto;那么问题来了，没有办法居中，但是设置了display:block以后就可以了，我一直以为canvas是块级元素，查了一下margin这样写不能居中的原因有哪些，一个是没声明文档类型，二是没设置宽度，三是可能使用了浮动属性，这些都没有问题，那是什么原因呢？于是我决定查一下canvas到底是什么元素，在segmentfault中发现了同样的一个问题，原来canvas是内联元素，并且是内联可置换元素。对于内联可置换元素来说，当margin-left和margin-right被设置为auto的时候，他的值为0。 &emsp;&emsp;一个内容不受CSS视觉格式化模型控制，CSS渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。 置换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。 行内级置换元素的宽高宽度： 若宽高的计算值都为 auto 且元素有固有宽度，则 width 的使用值为该固有宽度；典型的例子是：拥有默认宽高的 input 当宽度的计算值为auto时，则宽度使用值为其默认的固有宽度 若宽度的计算值为 auto 且元素有固有宽度，则 width 的使用值为该固有宽度；例子同上 若宽度的计算值为 auto 且高度有 非auto 的计算值，并且元素有固有宽高比，则 width 的使用值为 高度使用值 * 固有宽高比；典型的例子：img 当只定义了其高度值时，其宽度将会根据固有宽高比进行等比设置 除此之外，当 width 的计算值为 auto 时，则宽度的使用值为 300px典型的例子：比如iframe, canvas 高度： 若宽高的计算值都为 auto 且元素有固有高度，则 height 的使用值为该固有高度； 若高度的计算值为 auto 且元素有固有高度，则 height 的使用值为该固有高度； 若高度的计算值为 auto 且宽度有 非auto 的计算值，并且元素有固有宽高比，则 height 的使用值为：宽度使用值 / 固有宽高比； 若高度的计算值为 auto 且上述条件完全不符，则 height 的使用值 不能大于150px，且宽度不能大于长方形高度的2倍。 其它类型置换元素的宽高的定义都参照行内置换元素的定义 其它说明 置换元素有:img,input,select,textarea,object,canvas,iframe等 同样容易被混淆的内联元素有： img 内联置换元素 inline-block: selecttextareainputbutton 块级元素 ul 块元素和块级元素的区别是 块元素只是display:block的元素块级元素也可以是display:table | list-item | flex | grid","categories":[{"name":"HTML","slug":"HTML","permalink":"https://shizhihuaxu.github.io/categories/HTML/"}],"tags":[{"name":"置换元素","slug":"置换元素","permalink":"https://shizhihuaxu.github.io/tags/置换元素/"}]},{"title":"js的隐式数据类型转换规则（一）原理篇","slug":"one-type-conversion","date":"2018-08-02T03:18:39.422Z","updated":"2018-08-02T06:19:30.579Z","comments":true,"path":"2018/08/02/one-type-conversion/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/one-type-conversion/","excerpt":"","text":"隐式类型转换隐式数据类型转换通常发生在比较大小，是否相等，加减乘除等运算、或当前运行环境的默认输出类型为固定值时。 例如：使用非严格相等操作符(==)判断两个值是否相等时，如果两个值的类型不同（typeof），会将两个值隐式的转化为相同的类型后再执行严格相等的比较。（其中一个或者两个值都发生类型转换） 1.原始类型之间的转换使用Number(),String(),Boolean()。 原始值 转化为数值类型 转化为字符串类型 转化为布尔类型 false 0 “false” true 1 “true” +0或-0 ‘’+0”或”-0” false 1 “1” true NAN “NAN” false infinity “infinity” true -infinity “-infinity” true undefined NAN “undefined” false null 0 “null” false “” 0 false “10” 10 true “abcd” NAN true 2.当引用类型转换为基本类型时则使用ToPrimitive函数。 123456789101112131415161718192021222324252627ToPrimitive(input, PreferredType?)的简单实现，代码来源于：https://zhuanlan.zhihu.com/p/29064256 var ToPrimitive = function(obj,preferredType)&#123; var APIs = &#123; typeOf: function(obj)&#123; return Object.prototype.toString.call(obj).slice(8,-1); &#125;, isPrimitive: function(obj)&#123; var _this = this, types = ['Null','Undefined','String','Boolean','Number']; return types.indexOf(_this.typeOf(obj)) !== -1; &#125; &#125;; // 如果 obj 本身已经是原始对象，则直接返回 if(APIs.isPrimitive(obj)) &#123;return obj;&#125; // 对于 Date 类型，会优先使用其 toString 方法；否则优先使用 valueOf 方法 preferredType = (preferredType === 'String' || APIs.typeOf(obj) === 'Date' ) ? 'String' : 'Number'; if(preferredType==='Number')&#123; if(APIs.isPrimitive(obj.valueOf())) &#123; return obj.valueOf()&#125;; if(APIs.isPrimitive(obj.toString())) &#123; return obj.toString()&#125;; &#125;else&#123; if(APIs.isPrimitive(obj.toString())) &#123; return obj.toString()&#125;; if(APIs.isPrimitive(obj.valueOf())) &#123; return obj.valueOf()&#125;; &#125; throw new TypeError('TypeError');&#125; 原始值 转化为数值类型 转化为字符串类型 转化为布尔类型 [] 0 “” true [10] 10 “10” true [1,2] NaN “1,2” true [“10”] 10 “10” true [“abcd”] NaN “abcd” true function(){} NaN “function(){}” true {} NaN “[object Object]” true 以下几种类型在转化为布尔值时为false，其它的均为truenull，undefined，0，””，NaN（共五种） 注意:如果使用new操作符创建的对象隐式转换为boolean类型都是true，哪怕是new String(”); 运行环境和操作符对隐式类型转换的影响数据到底是被转化为number还是string受到运行环境和操作符的影响。 运行环境的影响​ 很多内置函数期望传入的参数的数据类型是固定的，如:alert(value)方法，它期望传入的value值是一个string类型，但是如果我们传入的是number类型或者object类型等非string类型的数据的时候，就会发生数据类型的隐式转换。这就是环境运行环境对数据类型转换的影响 操作符的影响 当+号作为一元操作符操作单操作数的时候，他就会将这个数转换为Number类型 当+号作为二元操作符时，如果两个操作数中存在一个String类型的话，那么另外一个操作数也会无条件地转换为字符串. 在第1步转换后，如果有运算元出现原始数据类型是”字符串”类型值时，则另一运算元作强制转换为字符串，然后作字符串的连接运算(concatenation)。 当+号作为二元操作符时，如果两个操作数一个都不是字符串的话，两个操作数会隐式转换成数字类型(如果无法成功转换成数字，则变成NaN，再往下操作)，再进行加法算数操作. 当算数运算的操作符是+号以外的其他操作数时，两个操作数都会转成数字类型进行数字运算。 == 与！=操作符的运算规则1234567891011121314151617x==y的判断1.如果x与y的类型（typeof）相同，存在以下几个特殊情况需要注意 a.如果x与y均为undefined,或null,返回true b.如果x与y均为number类型，且至少有一个值为NAN,返回false c.+0==-0,返回true d.undefined==null,返回true e.x,y均为某个对象的实例，返回true2.如果 x,y 类型不一致，且 x,y 为 String、Number、Boolean 中的某一类型，则将 x,y 使用 toNumber 函数转化为 Number 类型再进行比较。3.如果 x，y 中有一个为 Object，则首先使用 ToPrimitive 函数将其转化为原始类型，再进行比较。 复杂对象转换原理复杂对象是以什么标准来判断ToPrimitive(input,preferredType)操作传入的preferredType值到底是number还是string呢？（可以见上面代码部分，这里做个简单说明） 如果运行环境非常明确的需要将一个复杂对象转换为数字则传入number如 Number(value) 和 +value 则传入number 如果运行环境非常明确的需要将一个复杂对象转换为字符串则传入string如String(value) 和 alert(value) 则传入string 如果是用+号连接两个操作数，操作数在确定确定其中只要有一个为字符串的时候另外一个操作数会转为字符串，ToPrimitive()会传入string，但是如果两个操作数都不能确定是字符串的时候则默认传入number进行数据类型转换(Date对象是一个例外，它会默认传入string)。 ToPrimitive的转换示例12345[\"12\"]+1; //‘121’[\"12\"].valueOf() // [\"12\"][\"12\"].toString() //\"12\" 首先对于这个引用类型preferredType参数默认会是number，这个时候调用传入对象的valueOf()方法，如果他的返回值类型是一个基本类型，那么就返回这个值，如果不是，则调用toString()方法，返回这个基本类型的值。","categories":[{"name":"Data type conversion","slug":"Data-type-conversion","permalink":"https://shizhihuaxu.github.io/categories/Data-type-conversion/"}],"tags":[{"name":"隐式数据类型转换原理","slug":"隐式数据类型转换原理","permalink":"https://shizhihuaxu.github.io/tags/隐式数据类型转换原理/"}]},{"title":"HTML5+PHP文件上传学习笔记","slug":"fileUpload","date":"2018-08-02T03:18:39.416Z","updated":"2018-08-02T06:19:13.617Z","comments":true,"path":"2018/08/02/fileUpload/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/fileUpload/","excerpt":"","text":"几个上传插件的分析对比下面是我整理的几个插件的分析对比数据，只选择几项展开说明，仅供参考。 项目 Uploadify Plupload2.3.1 DropZone.js Fine Uploader5.15.0 兼容性 IE 8+ IE 6+ IE 10+ IE 8+ 多文件 支持 支持 支持 IE10+ 图片预览 不支持 不支持 支持 支持（IE 10+） 拖拽上传 html5版本支持 仅html5版支持chrome21+支持文件夹 支持 支持（甚至chrome和opera15+中的文件夹） 大文件 分块上传 分块上传 自动上传 支持 不支持 不支持 支持 进度条 有 无 无 可自定义（IE10+） 功能亮点 1、flash和html5两个版本2、可更改上传的文件名3、由接口参数和CSS控制外观4、高度可定制 1、自动侦测环境，多种上传方式，兼容性好。2、支持自动重试3、依赖自由4、图片上传前压缩5、多文件队列上传 1、全面的事件处理选项2、依赖自由3、可删除已上传的文件 1、自动重传2、暂停\\恢复上传(IE10+)3、删除已上传文件4、粘贴上传（chrome,opera15+）5、无服务器上传6、提供服务器脚本或自定义7、使用接口控制外观 下载地址 http://www.uploadify.com/ http://www.plupload.com/ http://www.dropzonejs.com/ https://fineuploader.com/ (Uploadify有flash和html5两个版本，flash对IE兼容性较好，IE的7、8、9 不支持html5的File API 和xhr2使用FormData) 相关 API 详解XMLHttpRequest Level2 设置请求的超时时间 1234567var xhr=new XMLHttpRequest();//IE new ActiveXObject('Microsoft.XMLHTTP');xhr.timeout=1000;//(ms)xhr.ontimeout=function(e)&#123;&#125; 接收二进制数据 123xhr.responseText='blob'//或ArrayBuffer数组 二进制;var blob = new Blob([xhr.response], &#123;type: ''&#125;); 进度 ​ 监听progress事件，需要注意的是，上传的progress属于XMLHttpRequest.upload对象，下载的progress属于XMLHttpRequest对象 12345678xhr.upload.onprogress=function(e)&#123; if(e.lengthComputable)&#123; //lengthComputable是一个表示进度信息是否可用的布尔值 //loaded表示已经接收的字节数，total表示根据Content-Length响应头部确定的预期字节数。 var percent=e.loaded/e.total; console.log(percent); &#125; &#125; 终止 方法：abort() 事件：onabort 其它事件(IE9+) loadstart 当接收到数据的第一个字节时触发 error 发生错误时触发 load 接收到完整数据时触发 loadend 在通信完成或者触发error、abort或load事件后触发 FileList1&lt;input type=&quot;file&quot; multiple=&quot;multiple&quot;/&gt; //IE10+ 支持multiple属性 当没有multiple属性时，FileList的长度为1，需要注意的是FileList对象不能在js中直接访问 File继承Blob对象的所有属性和方法 所有属性均为只读属性 lastModified 最后的修改时间 时间戳 IE10+ lastModifiedData 不再提倡使用，但是还可以使用 name 文件名 IE11+ size 文件大小 IE11+ type 文件类型 slice(start，end); FileReader readyState EMPTY 0 尚未加载数据。 LOADING 1 数据正在加载。 DONE 2 整个读取请求已经完成。 error 读取文件时发生的错误 result 文件的内容 事件处理程序 (1) loadstart 开始读取时 (2) progress 读取时 (3) abort 中止时 (4) error 发生错误时 (5) load 读取操作成功时 (6) loadend 读取完成（成功或失败）时 方法 (1) readAsDataURL() (2) readAsText() (3) readAsArrayBuffer() (4) abort() 中止读操作 实现部分功能的思路 xhr2新增了formData接口，可以通过js用一些键值对来模拟一系列表单控件。使用FormData的最大优点就是可以异步上传二进制文件，二进制文件一般除文本文件外的图形文件、可执行文件等。设置enctype=”multipart/form-data”,可上传二进制数据，用于表单里有图片上传。默认情况，这个编码格式是application/x-www-form-urlencoded，不能用于文件上传。 非IE6版本的IE由于安全问题直接设置img的src无法显示本地图片，可以将图片转换为base64编码。 多文件上传多文件上传源码，后台使用$_FIlES对上传结果遍历，并将这些临时文件移动到保存上传图片的文件夹的操作，在此不做详细说明。 文件分块上传 defmain 前辈的文章PHP搭建大文件切割分块上传功能 提供了一个一个很好的思路。 前端主要是利用html5的File API 的slice方法对文件进行分割，使用 xhr2的FormData对象构造上传数据。 拖放上传这里使用到了HTMl5 拖放的API DataTransfer对象 (1) DataTransfer.files包含数据传输上可用的所有本地文件的列表。如果拖动操作不涉及拖动文件，则此属性是空列表。 (2) DataTransfer.types 只读 strings提供在dragstart事件中设置的格式的数组。 1234567&lt;input id=\"mylist\" type=\"file\"/&gt;var dropZone=document.getElementById(\"mylist\");dropZone.ondrop=function(e)&#123; console.log(e.dataTransfer.files[0]);&#125; 图片预览​ 使用html5的FileReader读取本地文件，包括readAsText(),readAsDataURL(),readAsArrayBuffer()三个方法。 123456789101112131415161718//创建一个FileReader对象&lt;input id=\"myfile\" type=\"file\"/&gt; &lt;img src=\"\" id=\"img\"/&gt; var myfile=document.getElementById(\"myfile\"), img=document.getElementById(\"img\"), reader=new FileReader(); myfile.ondrop=function(e)&#123; var url=\"\"; reader.readAsDataURL(e.dataTransfer.files[0]); reader.onload = function(evt) &#123; url = evt.target.result; img.setAttribute(\"src\",url); &#125; &#125; 进度条通过监听 xhr.upload.onprogress实现上传进度条效果。12345678910var xhr=new window.XMLHttpRequest();xhr.upload.onprogress=function(e)&#123; if(e.lengthComputable)&#123; //lengthComputable是一个表示进度信息是否可用的布尔值 //loaded表示已经接收的字节数，total表示根据Content-Length响应头部确定的预期字节数。 var percent=e.loaded/e.total; console.log(percent); &#125; &#125; 压缩上传 读取数据 创建一个image对象，监听他的onload事件 根据压缩比例算出宽高 使用canvas将图片画出来按照此宽高画出来 使用toDataURL读取成base64数据的形式上传（怎样上传） 上传 base64数据的形式是这种形式的:data:image/png;base64,someString…. 1234567891011121314151617function dataURItoBlob(dataURI) &#123; var byteString = atob(dataURI.split(',')[1]); var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; var ab = new ArrayBuffer(byteString.length); var ia = new Uint8Array(ab); for (var i = 0; i &lt; byteString.length; i++) &#123; ia[i] = byteString.charCodeAt(i);//老版本的做法 还原成二进制的字符 &#125; return new Blob([ab], &#123;type: mimeString&#125;);&#125;var fd = new FormData();var blob = dataURItoBlob(dataURL);fd.append('file', blob);上传时data:fd","categories":[{"name":"文件上传","slug":"文件上传","permalink":"https://shizhihuaxu.github.io/categories/文件上传/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://shizhihuaxu.github.io/tags/文件上传/"}]},{"title":"js 写一个倒计时函数","slug":"countDown","date":"2018-08-02T03:18:39.406Z","updated":"2018-08-02T06:18:02.522Z","comments":true,"path":"2018/08/02/countDown/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/countDown/","excerpt":"","text":"Date对象Date.parse(dateString)返回从1970年1月1日到dateString指定的日期的毫秒数 dateString有如下几点限制（这部分内容是从river.cao的博客看到的) 短日期可使用 / 日期分隔符，但是必须符合 月/日/年 的格式，例如 7/20/96 或 6/15/2008 。 以 July 10 1995 形式表示的长日期中的年、月、日可以按任何顺序排列，而且年份可以用2位数或4位数的形式表示。如果使用2位数的形式来表示年份，则该年份必须大于或等于 70。 逗号 和空格被视为分隔符。允许使用多个分隔符。 月和日的名称必须具有两个或两个以上的字符。如果两个字符所组成的名称不唯一，则该名称将解析为最晚的一个匹配日期。例如， Ju 解析为七月( July )，而不是六月( June )。Chrome不支持”Ju”这种写法。 如果提供一个日期，该日期中所说明的星期数与根据此日期中其他部分所确定的星期数不相符，则此日期中的星期数将被忽略。例如，尽管 1996 年 11 月 9 日实际上是星期五，但 Tuesday November 9 1996 还是可以被接受并进行分析。但是结果的 Date 对象中包含的是 Friday November 9 1996 。 用冒号分隔小时、分钟和秒，但所有这些内容并非都需要指定。 10: 、 10:11 和 10:11:12 都是有效的。 dateObj.getTime()&emsp;&emsp;dateObject 指定的日期和时间距 1970 年 1 月 1 日午夜（GMT 时间）之间的毫秒数。 代码这里我只写了一个思路，还有不严谨之处，仅供参考 &emsp;&emsp;这里我只写了一个思路，还有不严谨之处，仅供参考 12345678910111213141516171819202122232425262728var countDown=function(date)&#123; var pre=Date.parse(date); var loop=setInterval(function()&#123; var d=new Date(), now=d.getTime(), diff=pre-now; var hour=0, minutes=0, seconds=0; diff=Math.round(diff/1000); seconds=Math.round(diff%60); minutes=Math.round(diff/60%60); hour=Math.round(diff/3600); if(hour==0&amp;&amp;minutes==0&amp;&amp;seconds==0)&#123; clearInterval(loop); console.log('时间到啦'); &#125; console.log('还剩 hour '+hour+' minutes '+minutes+' seconds '+seconds); &#125;,1000) &#125; //使用方法 //countDown('10/06/2017 22:19:00'); 要写到具体的日期的某个时间点","categories":[{"name":"Date对象","slug":"Date对象","permalink":"https://shizhihuaxu.github.io/categories/Date对象/"}],"tags":[{"name":"Data对象","slug":"Data对象","permalink":"https://shizhihuaxu.github.io/tags/Data对象/"}]},{"title":"在ThinkPHP5.0.11中使用 CKEditor、CKFinder","slug":"ckeditor","date":"2018-08-02T03:18:39.404Z","updated":"2018-08-02T06:17:53.705Z","comments":true,"path":"2018/08/02/ckeditor/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/ckeditor/","excerpt":"","text":"插件下载地址CKEditor CKFinder 配置步骤及常见问题说明配置步骤 ​ 在页面中引入js,这里如果你使用了jquery 需要引入adapters/jquery.js 123&lt;script src=&quot;/ckeditor/ckeditor.js&quot;&gt;&lt;/script&gt; //插件的位置 根据你的保存的路径设置&lt;script src=&quot;/ckeditor/adapters/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/ckfinder/ckfinder.js&quot;&gt;&lt;/script&gt; 在页面中初始化CKEditor 12345var myeditor=CKEDITOR.replace('content',&#123; filebrowserBrowseUrl: \"/ckfinder/ckfinder.html\", filebrowserImageBrowseUrl: '/ckfinder/ckfinder.html?Type=Images', filebrowserImageUploadUrl: '/plugins/ckfinder/core/connector/php/connector.php？command=QuickUpload&amp;type=Images' &#125;); 在未做如上配置之前,CKEditor 点击上传图片的图标是没有上传按钮的,网上有一些教程说是插件默认将这个按钮style设置为隐藏了,提供的解决办法是找到相应的位置修改css,其实只要配置了上传图片的处理文件路径,“ 上传 ”按钮就会显示出来。 整合CKEditor 和 CKFinder CKEditor 只是一个富文本编辑器，没有文件浏览和文件上传的功能, CKFinder是用来上传文件和浏览服务器上的文件的，和CKEditor配合实现文件上传。 1CKFinder.setupCKEditor(myeditor,&quot;/ckfinder/&quot;); //ckfinder插件存放的相对路径 ​ 图片上传 首先在 ckfinder/config.php 中找到 $baseUrl = ‘/userfiles/‘ ,将其设置为你要保存上传文件的路径,你也可以动态设置地址。 再向下可以找到 $config[‘ResourceType’]为Images 的配置项，这里对上传图片的大小、扩展名进行配置。 常见问题首先记得更改任何配置，如果没有效果要手动清除一下浏览器缓存,使用ctrl+F5也不能全部刷新,导致我花了一下午时间找问题，才发现其实已经配置好了。 隐藏 “浏览服务器文件按钮” 1在 ckeditor/plugins/image/dialogs/image.js 找到仅有的一项 display:inline-block 将其设置为display:none;就可以隐藏掉了 缺少图像源文件地址 这是由于预览没有权限读取上传的文件的地址,更改浏览服务器文件的权限，只有用户登录后或当前用户只能查看自己上传到服务器的文件 ,在登录成功后设置一个授权字段到session中 ,不建议直接改为true,安全性较低。 1234567session_start();if(isset($_SESSION['IsAuthorized'])&amp;&amp;$_SESSION['IsAuthorized']==true)&#123; return true;&#125;else&#123; return false;&#125; 上传文件重名问题 ckfinder会按照原有的名字命名，中文的情况下可能会乱码，所以建议使用日期重命名。 1234567打开/ckfinder/core/connector/php/php5/CommandHandler/FileUpload.php 找到 sUnsafeFileName=CKFinder_Connector_Utils_FileSystem::convertToFilesystemEncoding(CKFinder_Connector_Utils_Misc::mbBasename(uploadedFile[&apos;name&apos;])); 后面加上 sExtension = CKFinder_Connector_Utils_FileSystem::getExtension(sUnsafeFileName);sUnsafeFileName=date(&apos;YmdHis&apos;).&apos;.&apos;.sExtension; 上传和图像对调位置 修改ckeditor/plugins/image/dialogs/image.js 文件。其实按钮的位置是按照以下方式排列的 ，所以只要将 uplaod部分的内容放在contents数组的第一个就好了。 123456contents:[&#123; id:&quot;info&quot; ...., id:&quot;Upload&quot; ...., id:&quot;Link&quot; ...., id:&quot;advanced&quot; ....,&#125;] ​ 清空预览区文字 123在ckeditor/config.js添加配置项 config.image_previewText=&apos; &apos;; //预览区域显示内容 去除掉不需要的选项卡 1config.removeDialogTabs = &quot;image:advanced;image:Link;&quot;; //去掉上传图片时超链接和高级按钮 获取内容，并判断是否为空 方法一：原生的方法 12editor 为初始化时创建的实例editor.document.getBody().getText() 方法二：直接getData获取数据时如果使用了空格、回车，会添加p标签，将空格转义，导致获取的长度永远不会为空。 1234567var content = editor.getData();content = content.replace(/(&amp;nbsp;)+/g,\"\");content = content.replace(/(&lt;p&gt;&lt;\\/p&gt;)+/g,\"\");content = $.trim(content);if(content==\"\")&#123;...&#125; 自定义菜单栏 参见文档可配置的项 123456// 工具栏（基础&apos;Basic&apos;、全能&apos;Full&apos;、自定义）plugins/toolbar/plugin.jsconfig.toolbar = &apos;Basic&apos;;config.toolbar = &apos;Full&apos;;编辑ckeditor目录下的的config.js文件，默认的是下面的工具栏代码，注意工具按钮是分组的，一个name内的大括号就是一个工具按钮分组，items后边是具体的按钮，“/”表示工具栏换行，“-”表示工具图标之间的中隔线“|” ​","categories":[{"name":"编辑器插件","slug":"编辑器插件","permalink":"https://shizhihuaxu.github.io/categories/编辑器插件/"}],"tags":[{"name":"CKEditor 4.5.10","slug":"CKEditor-4-5-10","permalink":"https://shizhihuaxu.github.io/tags/CKEditor-4-5-10/"},{"name":"CKFinder 2.0.2","slug":"CKFinder-2-0-2","permalink":"https://shizhihuaxu.github.io/tags/CKFinder-2-0-2/"}]},{"title":"数组去重的几种方式","slug":"array-unique","date":"2018-08-02T03:18:39.399Z","updated":"2018-08-02T06:17:09.967Z","comments":true,"path":"2018/08/02/array-unique/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/array-unique/","excerpt":"","text":"数组去重的几种方式借助ES6中Set数据结构成员的唯一性(注：以下内容来源于阮一峰老师的ES6入门在线文档) ​ ES6中Set数据结构是一个类数组结构，Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 ​ 向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。两个对象总是不等的。 ​ 再使用扩展运算符将Set转化为数组。 去重：[…new Set(array)] 借助Array.prototype.reduce()方法，先排序再去重12345678910let arr = [1,3,5,3,2,4,5];let result = arr.sort().reduce((init, current)=&gt;&#123; if(init.length === 0 || init[init.length-1]!==current)&#123; init.push(current); &#125; return init;&#125;, []);console.log(result); //[1, 2, 3, 4, 5] ​ 使用arr.sort()排序会存在一些问题，sort()默认的排序方法是根据字符串Unicode码点，在比较之前，元素会被转化成字符串，MDN上一个排序的例子： 123456var scores = [1, 10, 21, 2]; scores.sort(); //[1, 10, 2, 21]注意10在2之前,因为在 Unicode 指针顺序中\"10\"在\"2\"之前同样 Unicode 顺序上 \"80\" 要比 \"9\" 要靠前 所以尽量依照目前排序元素的特点，选择合适的compareFunction参数或选取其它方法。 遍历原有数组，利用 indexOf() 将非重复的值添加到新数组中去12345678910let arr = [1,3,5,3,2,4,5];let len = arr.length, newArr = []; for(let i=0;i&lt;len;i++)&#123; if(newArr.indexOf(arr[i])===-1)&#123; newArr.push(arr[i]); &#125;&#125;console.log(newArr); //[1, 3, 5, 2, 4] 建立一个哈希表1234567891011121314151617let arr = [1,3,5,3,2,4,5];function unique(a) &#123; let hash = &#123;&#125;, len = a.length, result = []; for (var i = 0; i &lt; len; i++)&#123; if (!hash[a[i]])&#123; hash[a[i]] = true; result.push(a[i]); &#125; &#125; return result;&#125;unique(arr); // 输出[1, 3, 5, 2, 4] ​","categories":[{"name":"js数组操作","slug":"js数组操作","permalink":"https://shizhihuaxu.github.io/categories/js数组操作/"}],"tags":[{"name":"数组去重","slug":"数组去重","permalink":"https://shizhihuaxu.github.io/tags/数组去重/"}]},{"title":"一段代码统计字符串中重复单词的思考","slug":"Array-reduce","date":"2018-08-02T03:18:39.398Z","updated":"2018-08-02T06:16:39.259Z","comments":true,"path":"2018/08/02/Array-reduce/","link":"","permalink":"https://shizhihuaxu.github.io/2018/08/02/Array-reduce/","excerpt":"","text":"统计重复字符&emsp;&emsp;看到一段代码，使用了reduce方法统计字符串中重复单词，现在我简化直接对数组进行操作，说说这么做的原理是什么。 123456var arr=[\"a\",\"b\",\"c\",\"b\",\"a\"]; arr.reduce(function(prev,next)&#123; prev[next]=(prev[next]+1)||1; return prev; &#125;,&#123;&#125;); arr.reduce(callback[, initialValue]) 回调函数第一次执行时， 123456789callback(previousValue, currentValue,currentIndex,array) - previousValue（上一次调用回调函数时的返回值，或者初始值） - currentValue（当前正在处理的数组元素） - currentIndex（当前正在处理的数组元素下标） - array（调用reduce()方法的数组） &emsp;&emsp;回调函数第一次执行时， 如果reduce有initialValue参数，那么 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值； 如果reduce没有 initialValue 参数，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。 再来看上面的那段代码，我试着输出了prev ,它是一个数组，在每一次循环中的结果时这样的 12345&#123;a: 1&#125;&#123;a: 1, b: 1&#125;&#123;a: 1, b: 1, c: 1&#125;&#123;a: 1, b: 2, c: 1&#125;&#123;a: 2, b: 2, c: 1&#125; next 则为每次循环的 currentValue 所以运行的过程应该是这样的： reduce参数获得了一个回调函数和一个空的对象作为初始值，在第一次回调时， prev={} &emsp; &emsp;next=”a” &emsp; &emsp; prev[“a”]=undefined||1然后返回prev这个数组，作为下一次的prev。 next=”b” prev[“b”]=1 &emsp; &emsp;……如此循环 对字符串的操作1234567var str=\"abcscd\", arr=str.split('');arr.reduce(function(prev,next)&#123; prev[next]=(prev[next]+1)||1; return prev;&#125;,&#123;&#125;);","categories":[{"name":"js数组","slug":"js数组","permalink":"https://shizhihuaxu.github.io/categories/js数组/"}],"tags":[{"name":"Array.prototype.reduce()","slug":"Array-prototype-reduce","permalink":"https://shizhihuaxu.github.io/tags/Array-prototype-reduce/"}]}]}